# JavaScript a compiled language 
# 翻译：JavaScript 一门编译型的语言

点击访问：[原文地址](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch1.md)

作者：[Kyle Simpson](https://github.com/getify)

## 编译型 vs 解释型

你之前可能听说过代码编译，但也许会把它看作一个神秘的黑盒子，源代码从盒子一头进去，可执行程序从盒子另一头出来。 

它其实并不神秘。代码编译是处理你编写的源代码，将其转换成机器可以理解的一串指令集。典型的方式是，将整个源代码一次性转换成指令集，并且将结果指令集保存到一个以后可以执行的输出中（通常是一个文件）。 

也许你还听过解释型，那么他和编译型有什么不同呢？ 

解释型操作和编译型操作类似，都是将源代码转换成机器可以理解的指令。但是，它们的处理模式有些不同。不像编译型操作一次性将源代码进行转换，解释型操作会一行一行地转换源代码；在处理下一行代码之前，当前的每一行代码都已经被执行了。

<figure>
    <img src="./illustrations/JSCompile/png01.png" width="650" alt="Code Compilation and Code Interpretation" align="center">
    <figcaption><em>Fig. 1: 编译型 vs. 解释型</em></figcaption>
    <br><br>
</figure>

图1 说明的编译型程序和解释型程序的运行过程 

这两种处理模式相互排斥吗？通常来说，是的。然而，现实中这个问题有些微妙，因为解释型操作可以采取其他形式，而不仅仅是一行一行地对源代码进行操作。现代的 JS 引擎在处理 JS 程序的时候，其实采取了编译型和解释型的变体。 

我们之前调查过这个话题，结论是，JS 被描绘成一种编译型语言更为准确。为了方便读者，下面的内容将会重新审视和扩展这一论断。

## 编译代码

首先，为什么 JS 是否被编译很重要？ 

作用域主要是在编译过程中确定的，因此理解编译和执行的关系是掌握作用域的关键。 

在经典的编译器理论中，一个程序被编译器分成三个基本阶段来处理：

1. **Token/词法分析**：将一串字符分解成有意义的块，叫做 Token 。比如，这句语句：`var a = 2；`。这句话可能会被分解成以下 token：`var`，`a`，`=`，`2` 和 `；`（分号）。空格可能会也可能不会被当作一个 token 保留下来，这取决于它是否有意义。 

2. **解析**：把一个 token 流（或者叫 token 数组）变成一棵由嵌套元素组成的树。这棵树代表着程序的语法结构。这被称作抽象语法树（Abstract Syntax Tree ：AST）。 

    比如，`var a = 2; ` 这句话的 AST 可能从一个 `VariableDeclaration` 的顶点开始，然后有一个子节点 `Identifier` （值为a），同时还有一个子节点 `AssignmentExpression` ，这个子节点中有一个名为 `NumericLiteral` （值为2）的子节点。 

3. **代码生成**：将 AST 转换成可执行代码。这部分会因为语言、平台和其他因素有很大不同。 

    JS 引擎采用刚刚为语句 `var a = 2;` 生成的 AST ，并将其转换成一组机器指令，从而真实地创建一个名为 `a` 的变量（包括保存到内存中），然后将 `2` 存储到 `a` 中。

| 注意: |
| :--- |
| JS 引擎的实现细节（包括利用系统内存资源等）比我们上面讲述的步骤要复杂很多。我们只将重点放在程序可观察的行为上，让 JS 引擎去管理这些更复杂的系统级别的抽象。 |

JS 引擎比这三个阶段的步骤要复杂很多。在解析和代码生成的过程中，有些步骤可以优化执行的性能（简化重复步骤）。事实上，代码甚至可以在执行的过程中重新编译和重新优化。

所以，我在这里只是粗略地描述一下。但是你很快就会明白为什么我们所涉及的这些细节，即使在“程序可观察的行为”这个层次上看，也是有用的。

JS 引擎没有充足的时间来执行它的工作并优化，因为 JS 的编译不像其他语言那样编译是在执行之前一次性完成。JS 通常必须在代码执行之前的几微秒（或者更少）的时间内发生。为了确保这些这些限制条件下的最快性能，JS 引擎使用了各种技巧（像 JIT、懒惰编译（lazy compile），甚至热重编译（hot re-compile）；这些都远远超越了我们现在讨论的范围。

### 需要两个阶段

尽可能简单地说，我们对于 JS 程序的处理过程，能观察到的是它至少发生了两个阶段：解析/编译和执行。 

解析/编译 和 执行阶段 的分离是可以观察到的事实，而不是理论或者观点。虽然 JS 规范中没有明确要求“编译”，但是它所要求的行为基本上只有在编译-执行的方式下才能实现。 

你可以通过观察三种程序特征来验证这一点：语法错误，早期错误和提升。

#### 语法错误

下面这段代码：

```js
var greeting = "Hello";

console.log(greeting);

greeting = ."Hi";
// SyntaxError: unexpected token .
// 语法错误：意外的token
```

这段代码没有任何输出（`“Hello”` 没有被打印出来），反而抛出了一个语法错误:意外的 token ，即在 `“Hi”` 字符串之前有一个意外的 `.`。语法错误发生在格式正常的 `console.log()` 语句之后，如果 JS 是从上到下逐行执行的，我们会期望在抛出语法错误之前打印出 `“Hello”`。这并没有发生。 

事实上，在执行第一和第二行之前，JS 引擎能够知道语法错误在第三行的唯一方法就是，在执行任何语句之前，JS 引擎已经解析了整个程序。

#### 早期错误

下面这段代码:

```js
console.log("Howdy");

saySomething("Hello","Hi");
// Uncaught SyntaxError: Duplicate parameter name not
// allowed in this context
// 未发现的语法错误：在这个上下文中不允许重复的参数名 

function saySomething(greeting, greeting) {
    "use strict";
    console.log(greeting);
}
```

尽管第一句代码格式正常，但是 `“Howdy”` 并没有被打印出来。 

相反，就像上一节所描述的那样，语法错误在程序执行之前被抛出来了。在这个例子中，函数 `saySomething` 中的严格模式（use Strict）禁止函数有重复的参数名；非严格模式下，这种情况是被允许的。 

抛出的错误不是像之前例子那种不正确 token 的语法错误。而是在严格模式下，JS 规范要求任何执行开始之前抛出的“早期错误”。 

但是 JS 引擎是如何知道 `greeting` 参数重复了？它是如何知道 `saySomething` 函数在处理参数列表时处于严格模式（“use strict”出现在函数内部）？ 

同样，唯一合理的解释是，在任何执行发生之前，代码必须已经被完全解析了。

#### 提升

下面这段代码:

```js
function saySomething() {
    var greeting = "Hello";
    {
        greeting = "Howdy";  // error comes from here | 错误发生在这里
        let greeting = "Hi";
        console.log(greeting);
    }
}

saySomething();
// ReferenceError: Cannot access 'greeting' before
// initialization
// 引用错误：在初始化之前不能访问‘greeting’ 
```
注意 `ReferneceError` 错误发生在语句 `greeting = "Howdy";` 那一行。情况是这样的，该语句使用的变量 `greeting`，属于下一行语句 `let greeting = "Hi";` 中的声明，而不是之前 `var greeting = "Hello";` 中的声明。 

JS 引擎知道抛出错误的那一行引用了下面一句声明的块作用域变量的唯一方法就是，JS 引擎已经在早期处理了这段代码，并且设置了所有作用域和变量的关联。这种作用域和声明的处理，只能在执行前通过解析程序才能准确地完成。

`ReferenceError` 错误在技术上是来自于 `greeting = "Howdy "` 过早地访问了 `greeting` 变量，这种冲突被称为暂时性死区（Temporal Dead Zone：TDZ）。以后将更详细地介绍这个问题。

| WARNING: |
| :--- |
| 人们经常断言，`let` 和 `const` 声明不会被提升，作为对刚才那段代码TDZ行为的另一种解释。但是这并不准确。我们将在以后的篇章中介绍提升和 `let` / `const` 的TDZ。 |

希望你现在可以相信 JS 程序在任何执行开始之前都被解析了，但是这能证明它们被编译了吗？ 

这是一个值得深思的问题。JS 是否能够解析一个程序，然后通过解释 AST 中表示的操作来执行这个程序，而不是首先编译该程序？是的，这是可以的。但是，这极不可能发生，主要因为这种行为在性能上是非常低效的。 

你很难想象一个生产率高效的 JS 引擎会排除万难将一个程序解析成 AST，但却没有将 AST 转换（又称“编译”）为最高效的方式（二进制），然后再执行。 

许多人尽量用这个术语来分辨，因为有很多细微之处和“嗯，实际上……”这类的感叹词。但是，在精神上和实践中，引擎处理 JS 程序时更像是编译而不是不编译。 

将 JS 归类到编译型语言，并不是为了关心二进制（或者字节码）可执行方式的分发模型，而是要在我们的头脑中对 JS 代码分析和处理阶段的保持清新区分。这个阶段明显且毫无争议地发生在代码开始执行之前。 

如果我们希望有效地理解 JS 和作用域。我们需要对 JS 引擎如何处理我们的代码建立适当的心理模型。 